{
  "address": "0xc5Bc8BCEED9F70488213db02e105439CfD177a59",
  "abi": [],
  "transactionHash": "0xef27ce24d3a510e619b9eba4c8592c092509c9ca8ab51e817f995e52c84a6728",
  "receipt": {
    "to": null,
    "from": "0x10E38dFfFCfdBaaf590D5A9958B01C9cfcF6A63B",
    "contractAddress": "0xc5Bc8BCEED9F70488213db02e105439CfD177a59",
    "transactionIndex": 0,
    "gasUsed": "67066",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x66c18562e7d04fcbb647d72dea32b364419489c6270be55c81c0eb3ccf2a30d4",
    "transactionHash": "0xef27ce24d3a510e619b9eba4c8592c092509c9ca8ab51e817f995e52c84a6728",
    "logs": [],
    "blockNumber": 2542283,
    "cumulativeGasUsed": "67066",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "67b48c09458e06a377b88495d468a835",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/weighted/RequiemWeightedMath.sol\":\"RequiemWeightedMath\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"contracts/interfaces/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\",\"keccak256\":\"0xb7230835a4efbbbebcb5371d121977e859388b33f3ee5d9a7a44fc4de8d6b970\",\"license\":\"MIT\"},\"contracts/libraries/helpers/InputHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../../interfaces/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./RequiemErrors.sol\\\";\\n\\nlibrary InputHelpers {\\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\\n        RequiemErrors._require(a == b, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureInputLengthMatch(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure {\\n        RequiemErrors._require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(address[] memory array) internal pure {\\n        if (array.length < 2) {\\n            return;\\n        }\\n\\n        address previous = array[0];\\n        for (uint256 i = 1; i < array.length; ++i) {\\n            address current = array[i];\\n            RequiemErrors._require(previous < current, Errors.UNSORTED_ARRAY);\\n            previous = current;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xec45066ec176d339a9c3edc33452b52e3b0a75f43af6e917629a80a9d2c5aa92\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/helpers/RequiemErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\n// solhint-disable\\nlibrary RequiemErrors {\\n    /**\\n     * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n     * supported.\\n     */\\n    function _require(bool condition, uint256 errorCode) internal pure {\\n        if (!condition) RequiemErrors._revert(errorCode);\\n    }\\n\\n    /**\\n     * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n     */\\n    function _revert(uint256 errorCode) internal pure {\\n        // We're going to dynamically create a revert string based on the error code, with the following format:\\n        // 'BAL#{errorCode}'\\n        // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n        //\\n        // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n        // number (8 to 16 bits) than the individual string characters.\\n        //\\n        // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n        // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n        // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n        assembly {\\n            // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n            // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n            // the '0' character.\\n\\n            let units := add(mod(errorCode, 10), 0x30)\\n\\n            errorCode := div(errorCode, 10)\\n            let tenths := add(mod(errorCode, 10), 0x30)\\n\\n            errorCode := div(errorCode, 10)\\n            let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n            // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\n            // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n            // characters to it, each shifted by a multiple of 8.\\n            // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n            // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n            // array).\\n\\n            let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n            // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n            // message will have the following layout:\\n            // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n            // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n            // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n            mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n            // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n            mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n            // The string length is fixed: 7 characters.\\n            mstore(0x24, 7)\\n            // Finally, the string itself is stored.\\n            mstore(0x44, revertReason)\\n\\n            // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n            // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n            revert(0, 100)\\n        }\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\\n    uint256 internal constant INVALID_INITIALIZATION = 342;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n    uint256 internal constant NOT_PAUSED = 431;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n}\\n\",\"keccak256\":\"0x26ec56b070a8871f0e043afd9f098b8152206bdfb96c1cde296a80af01582f52\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./LogExpMath.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        require(b <= a, \\\"SUB_OVERFLOW\\\");\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        require(a == 0 || product / a == b, \\\"MUL_OVERFLOW\\\");\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        require(a == 0 || product / a == b, \\\"MUL_OVERFLOW\\\");\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ZERO_DIVISION\\\");\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ZERO_DIVISION\\\");\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0xe2959bd91a7efbccc2258eb94d48a5fc1602fa52d51dc43799b0c38fccd9f60d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/math/LogExpMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \\u201cSoftware\\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \\u201cAS IS\\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../helpers/RequiemErrors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            // We solve the 0^0 indetermination by making it equal one.\\n            return uint256(ONE_18);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n        // x^y = exp(y * ln(x)).\\n\\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n        RequiemErrors._require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n        int256 x_int256 = int256(x);\\n\\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n        RequiemErrors._require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n        int256 y_int256 = int256(y);\\n\\n        int256 logx_times_y;\\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n            int256 ln_36_x = _ln_36(x_int256);\\n\\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n            // (downscaled) last 18 decimals.\\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n        } else {\\n            logx_times_y = _ln(x_int256) * y_int256;\\n        }\\n        logx_times_y /= ONE_18;\\n\\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n        RequiemErrors._require(\\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n            Errors.PRODUCT_OUT_OF_BOUNDS\\n        );\\n\\n        return uint256(exp(logx_times_y));\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        RequiemErrors._require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n\\n        if (x < 0) {\\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n            // Fixed point division requires multiplying by ONE_18.\\n            return ((ONE_18 * ONE_18) / exp(-x));\\n        }\\n\\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n        // decomposition.\\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest x_n.\\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n        // decomposition.\\n\\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n        // it and compute the accumulated product.\\n\\n        int256 firstAN;\\n        if (x >= x0) {\\n            x -= x0;\\n            firstAN = a0;\\n        } else if (x >= x1) {\\n            x -= x1;\\n            firstAN = a1;\\n        } else {\\n            firstAN = 1; // One with no decimal places\\n        }\\n\\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n        // smaller terms.\\n        x *= 100;\\n\\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n        int256 product = ONE_20;\\n\\n        if (x >= x2) {\\n            x -= x2;\\n            product = (product * a2) / ONE_20;\\n        }\\n        if (x >= x3) {\\n            x -= x3;\\n            product = (product * a3) / ONE_20;\\n        }\\n        if (x >= x4) {\\n            x -= x4;\\n            product = (product * a4) / ONE_20;\\n        }\\n        if (x >= x5) {\\n            x -= x5;\\n            product = (product * a5) / ONE_20;\\n        }\\n        if (x >= x6) {\\n            x -= x6;\\n            product = (product * a6) / ONE_20;\\n        }\\n        if (x >= x7) {\\n            x -= x7;\\n            product = (product * a7) / ONE_20;\\n        }\\n        if (x >= x8) {\\n            x -= x8;\\n            product = (product * a8) / ONE_20;\\n        }\\n        if (x >= x9) {\\n            x -= x9;\\n            product = (product * a9) / ONE_20;\\n        }\\n\\n        // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n        // The first term is simply x.\\n        term = x;\\n        seriesSum += term;\\n\\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n        term = ((term * x) / ONE_20) / 2;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 3;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 4;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 5;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 6;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 7;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 8;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 9;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 10;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 11;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 12;\\n        seriesSum += term;\\n\\n        // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n        // and then drop two digits to return an 18 decimal value.\\n\\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n        // upscaling.\\n\\n        int256 logBase;\\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n            logBase = _ln_36(base);\\n        } else {\\n            logBase = _ln(base) * ONE_18;\\n        }\\n\\n        int256 logArg;\\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n            logArg = _ln_36(arg);\\n        } else {\\n            logArg = _ln(arg) * ONE_18;\\n        }\\n\\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n        return (logArg * ONE_18) / logBase;\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        // The real natural logarithm is not defined for negative numbers or zero.\\n        RequiemErrors._require(a > 0, Errors.OUT_OF_BOUNDS);\\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n            return _ln_36(a) / ONE_18;\\n        } else {\\n            return _ln(a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        if (a < ONE_18) {\\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n            // Fixed point division requires multiplying by ONE_18.\\n            return (-_ln((ONE_18 * ONE_18) / a));\\n        }\\n\\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest a_n.\\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n        // ONE_18 to convert them to fixed point.\\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n        // by it and compute the accumulated sum.\\n\\n        int256 sum = 0;\\n        if (a >= a0 * ONE_18) {\\n            a /= a0; // Integer, not fixed point division\\n            sum += x0;\\n        }\\n\\n        if (a >= a1 * ONE_18) {\\n            a /= a1; // Integer, not fixed point division\\n            sum += x1;\\n        }\\n\\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n        sum *= 100;\\n        a *= 100;\\n\\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n        if (a >= a2) {\\n            a = (a * ONE_20) / a2;\\n            sum += x2;\\n        }\\n\\n        if (a >= a3) {\\n            a = (a * ONE_20) / a3;\\n            sum += x3;\\n        }\\n\\n        if (a >= a4) {\\n            a = (a * ONE_20) / a4;\\n            sum += x4;\\n        }\\n\\n        if (a >= a5) {\\n            a = (a * ONE_20) / a5;\\n            sum += x5;\\n        }\\n\\n        if (a >= a6) {\\n            a = (a * ONE_20) / a6;\\n            sum += x6;\\n        }\\n\\n        if (a >= a7) {\\n            a = (a * ONE_20) / a7;\\n            sum += x7;\\n        }\\n\\n        if (a >= a8) {\\n            a = (a * ONE_20) / a8;\\n            sum += x8;\\n        }\\n\\n        if (a >= a9) {\\n            a = (a * ONE_20) / a9;\\n            sum += x9;\\n        }\\n\\n        if (a >= a10) {\\n            a = (a * ONE_20) / a10;\\n            sum += x10;\\n        }\\n\\n        if (a >= a11) {\\n            a = (a * ONE_20) / a11;\\n            sum += x11;\\n        }\\n\\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n        // Let z = (a - 1) / (a + 1).\\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n        // division by ONE_20.\\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n        int256 z_squared = (z * z) / ONE_20;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 11;\\n\\n        // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n        seriesSum *= 2;\\n\\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n        // value.\\n\\n        return (sum + seriesSum) / 100;\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n        // worthwhile.\\n\\n        // First, we transform x to a 36 digit fixed point value.\\n        x *= ONE_18;\\n\\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n        // division by ONE_36.\\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n        int256 z_squared = (z * z) / ONE_36;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 11;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 13;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 15;\\n\\n        // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // All that remains is multiplying by 2 (non fixed point).\\n        return seriesSum * 2;\\n    }\\n}\\n\",\"keccak256\":\"0x7625ecc2db94810b99e4e74f03ccb8f2cd29e4f3ee2bb02baac696532472d537\",\"license\":\"MIT\"},\"contracts/libraries/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../helpers/RequiemErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library\\n */\\nlibrary Math {\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        RequiemErrors._require(b != 0, Errors.ZERO_DIVISION);\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        RequiemErrors._require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x08d70e0ac9ebce46772c157f02d18d9da78b4c1424a02bc7e4247028f02d925b\",\"license\":\"MIT\"},\"contracts/libraries/weighted/RequiemWeightedMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./../math/FixedPoint.sol\\\";\\nimport \\\"./../math/Math.sol\\\";\\nimport \\\"../helpers/InputHelpers.sol\\\";\\nimport \\\"../helpers/RequiemErrors.sol\\\";\\n\\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\\n// should be fixed.\\n// solhint-disable private-vars-leading-underscore\\n\\ncontract RequiemWeightedMath {\\n    using FixedPoint for uint256;\\n    // A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\\n    // implementation of the power function, as these ratios are often exponents.\\n    uint256 internal constant _MIN_WEIGHT = 0.01e18;\\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\\n    uint256 internal constant _MAX_WEIGHTED_TOKENS = 100;\\n\\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\\n    // ratio).\\n\\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\\n    uint256 internal constant _MAX_IN_RATIO = 0.3e18;\\n    uint256 internal constant _MAX_OUT_RATIO = 0.3e18;\\n\\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\\n    uint256 internal constant _MAX_INVARIANT_RATIO = 3e18;\\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\\n    uint256 internal constant _MIN_INVARIANT_RATIO = 0.7e18;\\n\\n    // About swap fees on joins and exits:\\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\\n    // swap fees, it follows that (some) joins and exits should as well.\\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\\n    // is the one to which swap fees are applied.\\n\\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\\n    // and, because there is a minimum BPT, we round down the invariant.\\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances) internal pure returns (uint256 invariant) {\\n        /**********************************************************************************************\\n        // invariant               _____                                                             //\\n        // wi = weight index i      | |      wi                                                      //\\n        // bi = balance index i     | |  bi ^   = i                                                  //\\n        // i = invariant                                                                             //\\n        **********************************************************************************************/\\n\\n        invariant = FixedPoint.ONE;\\n        for (uint256 i = 0; i < normalizedWeights.length; i++) {\\n            invariant = invariant.mulDown(balances[i].powDown(normalizedWeights[i]));\\n        }\\n\\n        RequiemErrors._require(invariant > 0, Errors.ZERO_INVARIANT);\\n    }\\n\\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\\n    // current balances and weights.\\n    function _calcOutGivenIn(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountIn\\n    ) internal pure returns (uint256) {\\n        /**********************************************************************************************\\n        // outGivenIn                                                                                //\\n        // aO = amountOut                                                                            //\\n        // bO = balanceOut                                                                           //\\n        // bI = balanceIn              /      /            bI             \\\\    (wI / wO) \\\\           //\\n        // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\\n        // wI = weightIn               \\\\      \\\\       ( bI + aI )         /              /           //\\n        // wO = weightOut                                                                            //\\n        **********************************************************************************************/\\n\\n        // Amount out, so we round down overall.\\n\\n        // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\\n        // Because bI / (bI + aI) <= 1, the exponent rounds down.\\n\\n        // Cannot exceed maximum in ratio\\n        RequiemErrors._require(amountIn <= balanceIn.mulDown(_MAX_IN_RATIO), Errors.MAX_IN_RATIO);\\n\\n        uint256 denominator = balanceIn + amountIn;\\n        uint256 base = balanceIn.divUp(denominator);\\n        uint256 exponent = weightIn.divDown(weightOut);\\n        uint256 power = base.powUp(exponent);\\n\\n        return balanceOut.mulDown(power.complement());\\n    }\\n\\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\\n    // current balances and weights.\\n    function _calcInGivenOut(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountOut\\n    ) internal pure returns (uint256) {\\n        /**********************************************************************************************\\n        // inGivenOut                                                                                //\\n        // aO = amountOut                                                                            //\\n        // bO = balanceOut                                                                           //\\n        // bI = balanceIn              /  /            bO             \\\\    (wO / wI)      \\\\          //\\n        // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\\n        // wI = weightIn               \\\\  \\\\       ( bO - aO )         /                   /          //\\n        // wO = weightOut                                                                            //\\n        **********************************************************************************************/\\n\\n        // Amount in, so we round up overall.\\n\\n        // The multiplication rounds up, and the power rounds up (so the base rounds up too).\\n        // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\\n\\n        // Cannot exceed maximum out ratio\\n        RequiemErrors._require(amountOut <= balanceOut.mulDown(_MAX_OUT_RATIO), Errors.MAX_OUT_RATIO);\\n\\n        uint256 base = balanceOut.divUp(balanceOut - amountOut);\\n        uint256 exponent = weightOut.divUp(weightIn);\\n        uint256 power = base.powUp(exponent);\\n\\n        // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\\n        // the following subtraction should never revert.\\n        uint256 ratio = power - FixedPoint.ONE;\\n\\n        return balanceIn.mulUp(ratio);\\n    }\\n\\n    function _calcBptOutGivenExactTokensIn(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        // BPT out, so we round down overall.\\n\\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\\n\\n        uint256 invariantRatioWithFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            balanceRatiosWithFee[i] = (balances[i] + amountsIn[i]).divDown(balances[i]);\\n            invariantRatioWithFees = invariantRatioWithFees + (balanceRatiosWithFee[i].mulDown(normalizedWeights[i]));\\n        }\\n\\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeJoinExactTokensInInvariantRatio(\\n            balances,\\n            normalizedWeights,\\n            amountsIn,\\n            balanceRatiosWithFee,\\n            invariantRatioWithFees,\\n            swapFeePercentage\\n        );\\n\\n        uint256 bptOut = (invariantRatio > FixedPoint.ONE) ? bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE) : 0;\\n        return (bptOut, swapFees);\\n    }\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep \\\"\\n     */\\n    function _computeJoinExactTokensInInvariantRatio(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256[] memory balanceRatiosWithFee,\\n        uint256 invariantRatioWithFees,\\n        uint256 swapFeePercentage\\n    ) private pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\\n        // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\\n        // increase.\\n        swapFees = new uint256[](amountsIn.length);\\n        invariantRatio = FixedPoint.ONE;\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            uint256 amountInWithoutFee;\\n\\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees - FixedPoint.ONE);\\n                uint256 taxableAmount = amountsIn[i] - nonTaxableAmount;\\n                uint256 swapFee = taxableAmount.mulUp(swapFeePercentage);\\n\\n                amountInWithoutFee = nonTaxableAmount + (taxableAmount - swapFee);\\n                swapFees[i] = swapFee;\\n            } else {\\n                amountInWithoutFee = amountsIn[i];\\n            }\\n\\n            uint256 balanceRatio = (balances[i] + amountInWithoutFee).divDown(balances[i]);\\n\\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\\n        }\\n    }\\n\\n    function _calcTokenInGivenExactBptOut(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256 amountIn, uint256 swapFee) {\\n        /******************************************************************************************\\n        // tokenInForExactBPTOut                                                                 //\\n        // a = amountIn                                                                          //\\n        // b = balance                      /  /    totalBPT + bptOut      \\\\    (1 / w)       \\\\  //\\n        // bptOut = bptAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\\n        // bpt = totalBPT                   \\\\  \\\\       totalBPT            /                  /  //\\n        // w = weight                                                                            //\\n        ******************************************************************************************/\\n\\n        // Token in, so we round up overall.\\n\\n        // Calculate the factor by which the invariant will increase after minting BPTAmountOut\\n        uint256 invariantRatio = (bptTotalSupply + bptAmountOut).divUp(bptTotalSupply);\\n        RequiemErrors._require(invariantRatio <= _MAX_INVARIANT_RATIO, Errors.MAX_OUT_BPT_FOR_TOKEN_IN);\\n\\n        // Calculate by how much the token balance has to increase to match the invariantRatio\\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divUp(normalizedWeight));\\n\\n        uint256 amountInWithoutFee = balance.mulUp(balanceRatio - FixedPoint.ONE);\\n\\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\\n        // accordingly.\\n        uint256 taxablePercentage = normalizedWeight.complement();\\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountInWithoutFee - taxableAmount;\\n\\n        uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage);\\n\\n        swapFee = taxableAmountPlusFees - taxableAmount;\\n        amountIn = nonTaxableAmount + taxableAmountPlusFees;\\n    }\\n\\n    function _calcAllTokensInGivenExactBptOut(\\n        uint256[] memory balances,\\n        uint256 bptAmountOut,\\n        uint256 totalBPT\\n    ) internal pure returns (uint256[] memory) {\\n        /************************************************************************************\\n        // tokensInForExactBptOut                                                          //\\n        // (per token)                                                                     //\\n        // aI = amountIn                   /   bptOut   \\\\                                  //\\n        // b = balance           aI = b * | ------------ |                                 //\\n        // bptOut = bptAmountOut           \\\\  totalBPT  /                                  //\\n        // bpt = totalBPT                                                                  //\\n        ************************************************************************************/\\n\\n        // Tokens in, so we round up overall.\\n        uint256 bptRatio = bptAmountOut.divUp(totalBPT);\\n\\n        uint256[] memory amountsIn = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsIn[i] = balances[i].mulUp(bptRatio);\\n        }\\n\\n        return amountsIn;\\n    }\\n\\n    function _calcBptInGivenExactTokensOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        // BPT in, so we round up overall.\\n\\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\\n        uint256 invariantRatioWithoutFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            balanceRatiosWithoutFee[i] = (balances[i] - amountsOut[i]).divUp(balances[i]);\\n            invariantRatioWithoutFees = invariantRatioWithoutFees + (balanceRatiosWithoutFee[i].mulUp(normalizedWeights[i]));\\n        }\\n\\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeExitExactTokensOutInvariantRatio(\\n            balances,\\n            normalizedWeights,\\n            amountsOut,\\n            balanceRatiosWithoutFee,\\n            invariantRatioWithoutFees,\\n            swapFeePercentage\\n        );\\n\\n        uint256 bptIn = bptTotalSupply.mulUp(invariantRatio.complement());\\n        return (bptIn, swapFees);\\n    }\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep \\\"\\n     */\\n    function _computeExitExactTokensOutInvariantRatio(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256[] memory balanceRatiosWithoutFee,\\n        uint256 invariantRatioWithoutFees,\\n        uint256 swapFeePercentage\\n    ) private pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\\n        swapFees = new uint256[](amountsOut.length);\\n        invariantRatio = FixedPoint.ONE;\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\\n            // 'token out'. This results in slightly larger price impact.\\n\\n            uint256 amountOutWithFee;\\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\\n                uint256 taxableAmount = amountsOut[i] - nonTaxableAmount;\\n                uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage);\\n\\n                swapFees[i] = taxableAmountPlusFees - taxableAmount;\\n                amountOutWithFee = nonTaxableAmount + taxableAmountPlusFees;\\n            } else {\\n                amountOutWithFee = amountsOut[i];\\n            }\\n\\n            uint256 balanceRatio = (balances[i] - amountOutWithFee).divDown(balances[i]);\\n\\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\\n        }\\n    }\\n\\n    function _calcTokenOutGivenExactBptIn(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256 amountOut, uint256 swapFee) {\\n        /*****************************************************************************************\\n        // exactBPTInForTokenOut                                                                //\\n        // a = amountOut                                                                        //\\n        // b = balance                     /      /    totalBPT - bptIn       \\\\    (1 / w)  \\\\   //\\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\\n        // bpt = totalBPT                  \\\\      \\\\       totalBPT            /             /   //\\n        // w = weight                                                                           //\\n        *****************************************************************************************/\\n\\n        // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\\n        // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\\n\\n        // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\\n        uint256 invariantRatio = (bptTotalSupply - bptAmountIn).divUp(bptTotalSupply);\\n        RequiemErrors._require(invariantRatio >= _MIN_INVARIANT_RATIO, Errors.MIN_BPT_IN_FOR_TOKEN_OUT);\\n\\n        // Calculate by how much the token balance has to decrease to match invariantRatio\\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divDown(normalizedWeight));\\n\\n        // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\\n        uint256 amountOutWithoutFee = balance.mulDown(balanceRatio.complement());\\n\\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\\n        // in swap fees.\\n        uint256 taxablePercentage = normalizedWeight.complement();\\n\\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountOutWithoutFee - taxableAmount;\\n\\n        swapFee = taxableAmount.mulUp(swapFeePercentage);\\n        amountOut = nonTaxableAmount + (taxableAmount - swapFee);\\n    }\\n\\n    function _calcTokensOutGivenExactBptIn(\\n        uint256[] memory balances,\\n        uint256 bptAmountIn,\\n        uint256 totalBPT\\n    ) internal pure returns (uint256[] memory) {\\n        /**********************************************************************************************\\n        // exactBPTInForTokensOut                                                                    //\\n        // (per token)                                                                               //\\n        // aO = amountOut                  /        bptIn         \\\\                                  //\\n        // b = balance           a0 = b * | ---------------------  |                                 //\\n        // bptIn = bptAmountIn             \\\\       totalBPT       /                                  //\\n        // bpt = totalBPT                                                                            //\\n        **********************************************************************************************/\\n\\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\\n        // multiplication and division.\\n\\n        uint256 bptRatio = bptAmountIn.divDown(totalBPT);\\n\\n        uint256[] memory amountsOut = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsOut[i] = balances[i].mulDown(bptRatio);\\n        }\\n\\n        return amountsOut;\\n    }\\n\\n    function _calcDueTokenProtocolSwapFeeAmount(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 previousInvariant,\\n        uint256 currentInvariant,\\n        uint256 protocolSwapFeePercentage\\n    ) internal pure returns (uint256) {\\n        /*********************************************************************************\\n        /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\\n        *********************************************************************************/\\n\\n        if (currentInvariant <= previousInvariant) {\\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\\n            return 0;\\n        }\\n\\n        // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\\n        // fees to the Vault.\\n\\n        // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\\n        // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\\n\\n        uint256 base = previousInvariant.divUp(currentInvariant);\\n        uint256 exponent = FixedPoint.ONE.divDown(normalizedWeight);\\n\\n        // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\\n        // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\\n        // 1 / min exponent) the Pool will pay less in protocol fees than it should.\\n        base = Math.max(base, FixedPoint.MIN_POW_BASE_FREE_EXPONENT);\\n\\n        uint256 power = base.powUp(exponent);\\n\\n        uint256 tokenAccruedFees = balance.mulDown(power.complement());\\n        return tokenAccruedFees.mulDown(protocolSwapFeePercentage);\\n    }\\n}\\n\",\"keccak256\":\"0x77bb4537636b77c8ab4a652cb134de2bde6164fcc524374fd2b5e6f22fcf593e\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122057b9b0559d9a8c1f862a4b4ed4534eeb73ccf7c14fe1adf2df343f265592622c64736f6c634300080a0033",
  "deployedBytecode": "0x6080604052600080fdfea264697066735822122057b9b0559d9a8c1f862a4b4ed4534eeb73ccf7c14fe1adf2df343f265592622c64736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}